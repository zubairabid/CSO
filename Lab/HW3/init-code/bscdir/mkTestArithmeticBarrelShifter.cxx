/*
 * Generated by Bluespec Compiler, version 2016.07.beta1 (build 34806, 2016-07-05)
 * 
 * On Thu Feb  1 22:35:02 IST 2018
 * 
 */
#include "bluesim_primitives.h"
#include "mkTestArithmeticBarrelShifter.h"


/* String declarations */
static std::string const __str_literal_2("PASSED ARITHMETIC", 17u);
static std::string const __str_literal_1("Shifter test failed:\n Input:    %b\n arithmetic shifted right by %d\n Expected: %b\n DUT:      %b\n",
					 95u);


/* Constructor */
MOD_mkTestArithmeticBarrelShifter::MOD_mkTestArithmeticBarrelShifter(tSimStateHdl simHdl,
								     char const *name,
								     Module *parent)
  : Module(simHdl, name, parent),
    __clk_handle_0(BAD_CLOCK_HANDLE),
    INST_counter(simHdl, "counter", this, 16u, 0u, (tUInt8)0u),
    INST_lfsr_r(simHdl, "lfsr_r", this, 32u, 1u, (tUInt8)0u),
    PORT_RST_N((tUInt8)1u)
{
  symbol_count = 5u;
  symbols = new tSym[symbol_count];
  init_symbols_0();
}


/* Symbol init fns */

void MOD_mkTestArithmeticBarrelShifter::init_symbols_0()
{
  init_symbol(&symbols[0u], "CAN_FIRE_RL_testShifter", SYM_DEF, &DEF_CAN_FIRE_RL_testShifter, 1u);
  init_symbol(&symbols[1u], "counter", SYM_MODULE, &INST_counter);
  init_symbol(&symbols[2u], "lfsr_r", SYM_MODULE, &INST_lfsr_r);
  init_symbol(&symbols[3u], "RL_testShifter", SYM_RULE);
  init_symbol(&symbols[4u], "WILL_FIRE_RL_testShifter", SYM_DEF, &DEF_WILL_FIRE_RL_testShifter, 1u);
}


/* Rule actions */

void MOD_mkTestArithmeticBarrelShifter::RL_testShifter()
{
  tUInt32 DEF_x__h11585;
  tUInt8 DEF_NOT_lfsr_r_SRA_lfsr_r_BITS_4_TO_0_8_9_EQ_IF_lf_ETC___d44;
  tUInt8 DEF_lfsr_r_BIT_31_0_CONCAT_lfsr_r_BIT_31_0___d21;
  tUInt8 DEF_counter_5_EQ_65535___d46;
  tUInt32 DEF_arithmeticExpected__h197;
  tUInt32 DEF_x__h125;
  tUInt32 DEF_num___1__h401;
  tUInt32 DEF_num___1__h293;
  tUInt32 DEF_arithmeticDUT__h198;
  tUInt32 DEF_num___1__h374;
  tUInt32 DEF_num___1__h347;
  tUInt32 DEF_num___1__h320;
  tUInt8 DEF_lfsr_r_BIT_0___h171;
  tUInt8 DEF_lfsr_r_BIT_1___h1142;
  tUInt8 DEF_lfsr_r_BIT_2___h1193;
  tUInt8 DEF_lfsr_r_BIT_3___h1244;
  tUInt8 DEF_lfsr_r_BIT_4___h1296;
  tUInt8 DEF_lfsr_r_BIT_5___h1348;
  tUInt8 DEF_lfsr_r_BIT_6___h1400;
  tUInt8 DEF_lfsr_r_BIT_7___h1452;
  tUInt8 DEF_lfsr_r_BIT_31___h2750;
  tUInt8 DEF_shamt__h195;
  tUInt32 DEF_a__h296;
  tUInt32 DEF_a__h323;
  tUInt32 DEF_a__h350;
  tUInt32 DEF_a__h377;
  tUInt32 DEF_lfsr_r_BITS_31_TO_1___d15;
  tUInt32 DEF_x__h11589;
  tUInt32 DEF_lfsr_r__h2748;
  DEF_lfsr_r__h2748 = INST_lfsr_r.METH_read();
  DEF_x__h11589 = INST_counter.METH_read();
  DEF_lfsr_r_BITS_31_TO_1___d15 = (tUInt32)(DEF_lfsr_r__h2748 >> 1u);
  DEF_shamt__h195 = (tUInt8)((tUInt8)31u & DEF_lfsr_r__h2748);
  DEF_lfsr_r_BIT_31___h2750 = (tUInt8)(DEF_lfsr_r__h2748 >> 31u);
  DEF_lfsr_r_BIT_7___h1452 = (tUInt8)((tUInt8)1u & (DEF_lfsr_r__h2748 >> 7u));
  DEF_lfsr_r_BIT_6___h1400 = (tUInt8)((tUInt8)1u & (DEF_lfsr_r__h2748 >> 6u));
  DEF_lfsr_r_BIT_5___h1348 = (tUInt8)((tUInt8)1u & (DEF_lfsr_r__h2748 >> 5u));
  DEF_lfsr_r_BIT_2___h1193 = (tUInt8)((tUInt8)1u & (DEF_lfsr_r__h2748 >> 2u));
  DEF_lfsr_r_BIT_4___h1296 = (tUInt8)((tUInt8)1u & (DEF_lfsr_r__h2748 >> 4u));
  DEF_lfsr_r_BIT_3___h1244 = (tUInt8)((tUInt8)1u & (DEF_lfsr_r__h2748 >> 3u));
  DEF_lfsr_r_BIT_1___h1142 = (tUInt8)((tUInt8)1u & (DEF_lfsr_r__h2748 >> 1u));
  DEF_lfsr_r_BIT_0___h171 = (tUInt8)((tUInt8)1u & DEF_lfsr_r__h2748);
  DEF_num___1__h401 = (((tUInt32)(DEF_lfsr_r_BIT_31___h2750)) << 31u) | DEF_lfsr_r_BITS_31_TO_1___d15;
  DEF_a__h377 = DEF_lfsr_r_BIT_0___h171 ? DEF_num___1__h401 : DEF_lfsr_r__h2748;
  DEF_x__h125 = DEF_lfsr_r_BIT_0___h171 ? ((((((((tUInt32)((tUInt8)1u)) << 31u) | (((tUInt32)(DEF_lfsr_r__h2748 >> 8u)) << 7u)) | (((tUInt32)((tUInt8)1u & ~DEF_lfsr_r_BIT_7___h1452)) << 6u)) | (((tUInt32)(DEF_lfsr_r_BIT_6___h1400)) << 5u)) | (((tUInt32)((tUInt8)1u & ~DEF_lfsr_r_BIT_5___h1348)) << 4u)) | (((tUInt32)(DEF_lfsr_r_BIT_4___h1296)) << 3u)) | (tUInt32)((tUInt8)7u & ~((tUInt8)((tUInt8)7u & (DEF_lfsr_r__h2748 >> 1u)))) : (((tUInt32)((tUInt8)0u)) << 31u) | DEF_lfsr_r_BITS_31_TO_1___d15;
  DEF_arithmeticExpected__h197 = primShiftRA32(32u,
					       32u,
					       (tUInt32)(DEF_lfsr_r__h2748),
					       5u,
					       (tUInt8)(DEF_shamt__h195));
  DEF_counter_5_EQ_65535___d46 = DEF_x__h11589 == 65535u;
  DEF_lfsr_r_BIT_31_0_CONCAT_lfsr_r_BIT_31_0___d21 = (tUInt8)3u & ((DEF_lfsr_r_BIT_31___h2750 << 1u) | DEF_lfsr_r_BIT_31___h2750);
  DEF_num___1__h374 = (((tUInt32)(DEF_lfsr_r_BIT_31_0_CONCAT_lfsr_r_BIT_31_0___d21)) << 30u) | (tUInt32)(DEF_a__h377 >> 2u);
  DEF_a__h350 = DEF_lfsr_r_BIT_1___h1142 ? DEF_num___1__h374 : DEF_a__h377;
  DEF_num___1__h347 = ((((tUInt32)(DEF_lfsr_r_BIT_31_0_CONCAT_lfsr_r_BIT_31_0___d21)) << 30u) | (((tUInt32)(DEF_lfsr_r_BIT_31_0_CONCAT_lfsr_r_BIT_31_0___d21)) << 28u)) | (tUInt32)(DEF_a__h350 >> 4u);
  DEF_a__h323 = DEF_lfsr_r_BIT_2___h1193 ? DEF_num___1__h347 : DEF_a__h350;
  DEF_num___1__h320 = ((((((tUInt32)(DEF_lfsr_r_BIT_31_0_CONCAT_lfsr_r_BIT_31_0___d21)) << 30u) | (((tUInt32)(DEF_lfsr_r_BIT_31_0_CONCAT_lfsr_r_BIT_31_0___d21)) << 28u)) | (((tUInt32)(DEF_lfsr_r_BIT_31_0_CONCAT_lfsr_r_BIT_31_0___d21)) << 26u)) | (((tUInt32)(DEF_lfsr_r_BIT_31_0_CONCAT_lfsr_r_BIT_31_0___d21)) << 24u)) | (tUInt32)(DEF_a__h323 >> 8u);
  DEF_a__h296 = DEF_lfsr_r_BIT_3___h1244 ? DEF_num___1__h320 : DEF_a__h323;
  DEF_num___1__h293 = ((((((((((tUInt32)(DEF_lfsr_r_BIT_31_0_CONCAT_lfsr_r_BIT_31_0___d21)) << 30u) | (((tUInt32)(DEF_lfsr_r_BIT_31_0_CONCAT_lfsr_r_BIT_31_0___d21)) << 28u)) | (((tUInt32)(DEF_lfsr_r_BIT_31_0_CONCAT_lfsr_r_BIT_31_0___d21)) << 26u)) | (((tUInt32)(DEF_lfsr_r_BIT_31_0_CONCAT_lfsr_r_BIT_31_0___d21)) << 24u)) | (((tUInt32)(DEF_lfsr_r_BIT_31_0_CONCAT_lfsr_r_BIT_31_0___d21)) << 22u)) | (((tUInt32)(DEF_lfsr_r_BIT_31_0_CONCAT_lfsr_r_BIT_31_0___d21)) << 20u)) | (((tUInt32)(DEF_lfsr_r_BIT_31_0_CONCAT_lfsr_r_BIT_31_0___d21)) << 18u)) | (((tUInt32)(DEF_lfsr_r_BIT_31_0_CONCAT_lfsr_r_BIT_31_0___d21)) << 16u)) | (tUInt32)(DEF_a__h296 >> 16u);
  DEF_arithmeticDUT__h198 = DEF_lfsr_r_BIT_4___h1296 ? DEF_num___1__h293 : DEF_a__h296;
  DEF_NOT_lfsr_r_SRA_lfsr_r_BITS_4_TO_0_8_9_EQ_IF_lf_ETC___d44 = !(DEF_arithmeticExpected__h197 == DEF_arithmeticDUT__h198);
  DEF_x__h11585 = 65535u & (DEF_x__h11589 + 1u);
  INST_lfsr_r.METH_write(DEF_x__h125);
  if (!(PORT_RST_N == (tUInt8)0u))
  {
    if (DEF_NOT_lfsr_r_SRA_lfsr_r_BITS_4_TO_0_8_9_EQ_IF_lf_ETC___d44)
      dollar_display(sim_hdl,
		     this,
		     "s,32,5,32,32",
		     &__str_literal_1,
		     DEF_lfsr_r__h2748,
		     DEF_shamt__h195,
		     DEF_arithmeticExpected__h197,
		     DEF_arithmeticDUT__h198);
    if (DEF_NOT_lfsr_r_SRA_lfsr_r_BITS_4_TO_0_8_9_EQ_IF_lf_ETC___d44)
      dollar_finish(sim_hdl, "32", 1u);
    if (DEF_counter_5_EQ_65535___d46)
      dollar_display(sim_hdl, this, "s", &__str_literal_2);
    if (DEF_counter_5_EQ_65535___d46)
      dollar_finish(sim_hdl, "32", 1u);
  }
  INST_counter.METH_write(DEF_x__h11585);
}


/* Methods */


/* Reset routines */

void MOD_mkTestArithmeticBarrelShifter::reset_RST_N(tUInt8 ARG_rst_in)
{
  PORT_RST_N = ARG_rst_in;
  INST_lfsr_r.reset_RST(ARG_rst_in);
  INST_counter.reset_RST(ARG_rst_in);
}


/* Static handles to reset routines */


/* Functions for the parent module to register its reset fns */


/* Functions to set the elaborated clock id */

void MOD_mkTestArithmeticBarrelShifter::set_clk_0(char const *s)
{
  __clk_handle_0 = bk_get_or_define_clock(sim_hdl, s);
}


/* State dumping routine */
void MOD_mkTestArithmeticBarrelShifter::dump_state(unsigned int indent)
{
  printf("%*s%s:\n", indent, "", inst_name);
  INST_counter.dump_state(indent + 2u);
  INST_lfsr_r.dump_state(indent + 2u);
}


/* VCD dumping routines */

unsigned int MOD_mkTestArithmeticBarrelShifter::dump_VCD_defs(unsigned int levels)
{
  vcd_write_scope_start(sim_hdl, inst_name);
  vcd_num = vcd_reserve_ids(sim_hdl, 5u);
  unsigned int num = vcd_num;
  for (unsigned int clk = 0u; clk < bk_num_clocks(sim_hdl); ++clk)
    vcd_add_clock_def(sim_hdl, this, bk_clock_name(sim_hdl, clk), bk_clock_vcd_num(sim_hdl, clk));
  vcd_write_def(sim_hdl, bk_clock_vcd_num(sim_hdl, __clk_handle_0), "CLK", 1u);
  vcd_set_clock(sim_hdl, num, __clk_handle_0);
  vcd_write_def(sim_hdl, num++, "CAN_FIRE_RL_testShifter", 1u);
  vcd_write_def(sim_hdl, num++, "RST_N", 1u);
  vcd_set_clock(sim_hdl, num, __clk_handle_0);
  vcd_write_def(sim_hdl, num++, "WILL_FIRE_RL_testShifter", 1u);
  num = INST_counter.dump_VCD_defs(num);
  num = INST_lfsr_r.dump_VCD_defs(num);
  vcd_write_scope_end(sim_hdl);
  return num;
}

void MOD_mkTestArithmeticBarrelShifter::dump_VCD(tVCDDumpType dt,
						 unsigned int levels,
						 MOD_mkTestArithmeticBarrelShifter &backing)
{
  vcd_defs(dt, backing);
  vcd_prims(dt, backing);
}

void MOD_mkTestArithmeticBarrelShifter::vcd_defs(tVCDDumpType dt,
						 MOD_mkTestArithmeticBarrelShifter &backing)
{
  unsigned int num = vcd_num;
  if (dt == VCD_DUMP_XS)
  {
    vcd_write_x(sim_hdl, num++, 1u);
    vcd_write_x(sim_hdl, num++, 1u);
    vcd_write_x(sim_hdl, num++, 1u);
  }
  else
    if (dt == VCD_DUMP_CHANGES)
    {
      if ((backing.DEF_CAN_FIRE_RL_testShifter) != DEF_CAN_FIRE_RL_testShifter)
      {
	vcd_write_val(sim_hdl, num, DEF_CAN_FIRE_RL_testShifter, 1u);
	backing.DEF_CAN_FIRE_RL_testShifter = DEF_CAN_FIRE_RL_testShifter;
      }
      ++num;
      if ((backing.PORT_RST_N) != PORT_RST_N)
      {
	vcd_write_val(sim_hdl, num, PORT_RST_N, 1u);
	backing.PORT_RST_N = PORT_RST_N;
      }
      ++num;
      if ((backing.DEF_WILL_FIRE_RL_testShifter) != DEF_WILL_FIRE_RL_testShifter)
      {
	vcd_write_val(sim_hdl, num, DEF_WILL_FIRE_RL_testShifter, 1u);
	backing.DEF_WILL_FIRE_RL_testShifter = DEF_WILL_FIRE_RL_testShifter;
      }
      ++num;
    }
    else
    {
      vcd_write_val(sim_hdl, num++, DEF_CAN_FIRE_RL_testShifter, 1u);
      backing.DEF_CAN_FIRE_RL_testShifter = DEF_CAN_FIRE_RL_testShifter;
      vcd_write_val(sim_hdl, num++, PORT_RST_N, 1u);
      backing.PORT_RST_N = PORT_RST_N;
      vcd_write_val(sim_hdl, num++, DEF_WILL_FIRE_RL_testShifter, 1u);
      backing.DEF_WILL_FIRE_RL_testShifter = DEF_WILL_FIRE_RL_testShifter;
    }
}

void MOD_mkTestArithmeticBarrelShifter::vcd_prims(tVCDDumpType dt,
						  MOD_mkTestArithmeticBarrelShifter &backing)
{
  INST_counter.dump_VCD(dt, backing.INST_counter);
  INST_lfsr_r.dump_VCD(dt, backing.INST_lfsr_r);
}
